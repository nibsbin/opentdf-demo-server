//*
// Flag evaluation API
//
// This proto forms the basis of a flag-evaluation API.
// It supports single and bulk evaluation RPCs, and flags of various types, as well as establishing a stream for getting notifications about changes in a flag definition.
// It supports the inclusion of a "context" with each evaluation, which may contain arbitrary attributes relevant to flag evaluation.

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: featureflag/featureflag.proto

package featureflagconnect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	featureflag "github.com/opentdf/platform/protocol/go/featureflag"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// FeatureFlagServiceName is the fully-qualified name of the FeatureFlagService service.
	FeatureFlagServiceName = "featureflag.FeatureFlagService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// FeatureFlagServiceResolveAllProcedure is the fully-qualified name of the FeatureFlagService's
	// ResolveAll RPC.
	FeatureFlagServiceResolveAllProcedure = "/featureflag.FeatureFlagService/ResolveAll"
	// FeatureFlagServiceResolveBooleanProcedure is the fully-qualified name of the FeatureFlagService's
	// ResolveBoolean RPC.
	FeatureFlagServiceResolveBooleanProcedure = "/featureflag.FeatureFlagService/ResolveBoolean"
	// FeatureFlagServiceResolveStringProcedure is the fully-qualified name of the FeatureFlagService's
	// ResolveString RPC.
	FeatureFlagServiceResolveStringProcedure = "/featureflag.FeatureFlagService/ResolveString"
	// FeatureFlagServiceResolveFloatProcedure is the fully-qualified name of the FeatureFlagService's
	// ResolveFloat RPC.
	FeatureFlagServiceResolveFloatProcedure = "/featureflag.FeatureFlagService/ResolveFloat"
	// FeatureFlagServiceResolveIntProcedure is the fully-qualified name of the FeatureFlagService's
	// ResolveInt RPC.
	FeatureFlagServiceResolveIntProcedure = "/featureflag.FeatureFlagService/ResolveInt"
	// FeatureFlagServiceResolveObjectProcedure is the fully-qualified name of the FeatureFlagService's
	// ResolveObject RPC.
	FeatureFlagServiceResolveObjectProcedure = "/featureflag.FeatureFlagService/ResolveObject"
)

// These variables are the protoreflect.Descriptor objects for the RPCs defined in this package.
var (
	featureFlagServiceServiceDescriptor              = featureflag.File_featureflag_featureflag_proto.Services().ByName("FeatureFlagService")
	featureFlagServiceResolveAllMethodDescriptor     = featureFlagServiceServiceDescriptor.Methods().ByName("ResolveAll")
	featureFlagServiceResolveBooleanMethodDescriptor = featureFlagServiceServiceDescriptor.Methods().ByName("ResolveBoolean")
	featureFlagServiceResolveStringMethodDescriptor  = featureFlagServiceServiceDescriptor.Methods().ByName("ResolveString")
	featureFlagServiceResolveFloatMethodDescriptor   = featureFlagServiceServiceDescriptor.Methods().ByName("ResolveFloat")
	featureFlagServiceResolveIntMethodDescriptor     = featureFlagServiceServiceDescriptor.Methods().ByName("ResolveInt")
	featureFlagServiceResolveObjectMethodDescriptor  = featureFlagServiceServiceDescriptor.Methods().ByName("ResolveObject")
)

// FeatureFlagServiceClient is a client for the featureflag.FeatureFlagService service.
type FeatureFlagServiceClient interface {
	ResolveAll(context.Context, *connect.Request[featureflag.ResolveAllRequest]) (*connect.Response[featureflag.ResolveAllResponse], error)
	ResolveBoolean(context.Context, *connect.Request[featureflag.ResolveBooleanRequest]) (*connect.Response[featureflag.ResolveBooleanResponse], error)
	ResolveString(context.Context, *connect.Request[featureflag.ResolveStringRequest]) (*connect.Response[featureflag.ResolveStringResponse], error)
	ResolveFloat(context.Context, *connect.Request[featureflag.ResolveFloatRequest]) (*connect.Response[featureflag.ResolveFloatResponse], error)
	ResolveInt(context.Context, *connect.Request[featureflag.ResolveIntRequest]) (*connect.Response[featureflag.ResolveIntResponse], error)
	ResolveObject(context.Context, *connect.Request[featureflag.ResolveObjectRequest]) (*connect.Response[featureflag.ResolveObjectResponse], error)
}

// NewFeatureFlagServiceClient constructs a client for the featureflag.FeatureFlagService service.
// By default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped
// responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewFeatureFlagServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) FeatureFlagServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &featureFlagServiceClient{
		resolveAll: connect.NewClient[featureflag.ResolveAllRequest, featureflag.ResolveAllResponse](
			httpClient,
			baseURL+FeatureFlagServiceResolveAllProcedure,
			connect.WithSchema(featureFlagServiceResolveAllMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		resolveBoolean: connect.NewClient[featureflag.ResolveBooleanRequest, featureflag.ResolveBooleanResponse](
			httpClient,
			baseURL+FeatureFlagServiceResolveBooleanProcedure,
			connect.WithSchema(featureFlagServiceResolveBooleanMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		resolveString: connect.NewClient[featureflag.ResolveStringRequest, featureflag.ResolveStringResponse](
			httpClient,
			baseURL+FeatureFlagServiceResolveStringProcedure,
			connect.WithSchema(featureFlagServiceResolveStringMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		resolveFloat: connect.NewClient[featureflag.ResolveFloatRequest, featureflag.ResolveFloatResponse](
			httpClient,
			baseURL+FeatureFlagServiceResolveFloatProcedure,
			connect.WithSchema(featureFlagServiceResolveFloatMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		resolveInt: connect.NewClient[featureflag.ResolveIntRequest, featureflag.ResolveIntResponse](
			httpClient,
			baseURL+FeatureFlagServiceResolveIntProcedure,
			connect.WithSchema(featureFlagServiceResolveIntMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		resolveObject: connect.NewClient[featureflag.ResolveObjectRequest, featureflag.ResolveObjectResponse](
			httpClient,
			baseURL+FeatureFlagServiceResolveObjectProcedure,
			connect.WithSchema(featureFlagServiceResolveObjectMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// featureFlagServiceClient implements FeatureFlagServiceClient.
type featureFlagServiceClient struct {
	resolveAll     *connect.Client[featureflag.ResolveAllRequest, featureflag.ResolveAllResponse]
	resolveBoolean *connect.Client[featureflag.ResolveBooleanRequest, featureflag.ResolveBooleanResponse]
	resolveString  *connect.Client[featureflag.ResolveStringRequest, featureflag.ResolveStringResponse]
	resolveFloat   *connect.Client[featureflag.ResolveFloatRequest, featureflag.ResolveFloatResponse]
	resolveInt     *connect.Client[featureflag.ResolveIntRequest, featureflag.ResolveIntResponse]
	resolveObject  *connect.Client[featureflag.ResolveObjectRequest, featureflag.ResolveObjectResponse]
}

// ResolveAll calls featureflag.FeatureFlagService.ResolveAll.
func (c *featureFlagServiceClient) ResolveAll(ctx context.Context, req *connect.Request[featureflag.ResolveAllRequest]) (*connect.Response[featureflag.ResolveAllResponse], error) {
	return c.resolveAll.CallUnary(ctx, req)
}

// ResolveBoolean calls featureflag.FeatureFlagService.ResolveBoolean.
func (c *featureFlagServiceClient) ResolveBoolean(ctx context.Context, req *connect.Request[featureflag.ResolveBooleanRequest]) (*connect.Response[featureflag.ResolveBooleanResponse], error) {
	return c.resolveBoolean.CallUnary(ctx, req)
}

// ResolveString calls featureflag.FeatureFlagService.ResolveString.
func (c *featureFlagServiceClient) ResolveString(ctx context.Context, req *connect.Request[featureflag.ResolveStringRequest]) (*connect.Response[featureflag.ResolveStringResponse], error) {
	return c.resolveString.CallUnary(ctx, req)
}

// ResolveFloat calls featureflag.FeatureFlagService.ResolveFloat.
func (c *featureFlagServiceClient) ResolveFloat(ctx context.Context, req *connect.Request[featureflag.ResolveFloatRequest]) (*connect.Response[featureflag.ResolveFloatResponse], error) {
	return c.resolveFloat.CallUnary(ctx, req)
}

// ResolveInt calls featureflag.FeatureFlagService.ResolveInt.
func (c *featureFlagServiceClient) ResolveInt(ctx context.Context, req *connect.Request[featureflag.ResolveIntRequest]) (*connect.Response[featureflag.ResolveIntResponse], error) {
	return c.resolveInt.CallUnary(ctx, req)
}

// ResolveObject calls featureflag.FeatureFlagService.ResolveObject.
func (c *featureFlagServiceClient) ResolveObject(ctx context.Context, req *connect.Request[featureflag.ResolveObjectRequest]) (*connect.Response[featureflag.ResolveObjectResponse], error) {
	return c.resolveObject.CallUnary(ctx, req)
}

// FeatureFlagServiceHandler is an implementation of the featureflag.FeatureFlagService service.
type FeatureFlagServiceHandler interface {
	ResolveAll(context.Context, *connect.Request[featureflag.ResolveAllRequest]) (*connect.Response[featureflag.ResolveAllResponse], error)
	ResolveBoolean(context.Context, *connect.Request[featureflag.ResolveBooleanRequest]) (*connect.Response[featureflag.ResolveBooleanResponse], error)
	ResolveString(context.Context, *connect.Request[featureflag.ResolveStringRequest]) (*connect.Response[featureflag.ResolveStringResponse], error)
	ResolveFloat(context.Context, *connect.Request[featureflag.ResolveFloatRequest]) (*connect.Response[featureflag.ResolveFloatResponse], error)
	ResolveInt(context.Context, *connect.Request[featureflag.ResolveIntRequest]) (*connect.Response[featureflag.ResolveIntResponse], error)
	ResolveObject(context.Context, *connect.Request[featureflag.ResolveObjectRequest]) (*connect.Response[featureflag.ResolveObjectResponse], error)
}

// NewFeatureFlagServiceHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewFeatureFlagServiceHandler(svc FeatureFlagServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	featureFlagServiceResolveAllHandler := connect.NewUnaryHandler(
		FeatureFlagServiceResolveAllProcedure,
		svc.ResolveAll,
		connect.WithSchema(featureFlagServiceResolveAllMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	featureFlagServiceResolveBooleanHandler := connect.NewUnaryHandler(
		FeatureFlagServiceResolveBooleanProcedure,
		svc.ResolveBoolean,
		connect.WithSchema(featureFlagServiceResolveBooleanMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	featureFlagServiceResolveStringHandler := connect.NewUnaryHandler(
		FeatureFlagServiceResolveStringProcedure,
		svc.ResolveString,
		connect.WithSchema(featureFlagServiceResolveStringMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	featureFlagServiceResolveFloatHandler := connect.NewUnaryHandler(
		FeatureFlagServiceResolveFloatProcedure,
		svc.ResolveFloat,
		connect.WithSchema(featureFlagServiceResolveFloatMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	featureFlagServiceResolveIntHandler := connect.NewUnaryHandler(
		FeatureFlagServiceResolveIntProcedure,
		svc.ResolveInt,
		connect.WithSchema(featureFlagServiceResolveIntMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	featureFlagServiceResolveObjectHandler := connect.NewUnaryHandler(
		FeatureFlagServiceResolveObjectProcedure,
		svc.ResolveObject,
		connect.WithSchema(featureFlagServiceResolveObjectMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/featureflag.FeatureFlagService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case FeatureFlagServiceResolveAllProcedure:
			featureFlagServiceResolveAllHandler.ServeHTTP(w, r)
		case FeatureFlagServiceResolveBooleanProcedure:
			featureFlagServiceResolveBooleanHandler.ServeHTTP(w, r)
		case FeatureFlagServiceResolveStringProcedure:
			featureFlagServiceResolveStringHandler.ServeHTTP(w, r)
		case FeatureFlagServiceResolveFloatProcedure:
			featureFlagServiceResolveFloatHandler.ServeHTTP(w, r)
		case FeatureFlagServiceResolveIntProcedure:
			featureFlagServiceResolveIntHandler.ServeHTTP(w, r)
		case FeatureFlagServiceResolveObjectProcedure:
			featureFlagServiceResolveObjectHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedFeatureFlagServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedFeatureFlagServiceHandler struct{}

func (UnimplementedFeatureFlagServiceHandler) ResolveAll(context.Context, *connect.Request[featureflag.ResolveAllRequest]) (*connect.Response[featureflag.ResolveAllResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("featureflag.FeatureFlagService.ResolveAll is not implemented"))
}

func (UnimplementedFeatureFlagServiceHandler) ResolveBoolean(context.Context, *connect.Request[featureflag.ResolveBooleanRequest]) (*connect.Response[featureflag.ResolveBooleanResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("featureflag.FeatureFlagService.ResolveBoolean is not implemented"))
}

func (UnimplementedFeatureFlagServiceHandler) ResolveString(context.Context, *connect.Request[featureflag.ResolveStringRequest]) (*connect.Response[featureflag.ResolveStringResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("featureflag.FeatureFlagService.ResolveString is not implemented"))
}

func (UnimplementedFeatureFlagServiceHandler) ResolveFloat(context.Context, *connect.Request[featureflag.ResolveFloatRequest]) (*connect.Response[featureflag.ResolveFloatResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("featureflag.FeatureFlagService.ResolveFloat is not implemented"))
}

func (UnimplementedFeatureFlagServiceHandler) ResolveInt(context.Context, *connect.Request[featureflag.ResolveIntRequest]) (*connect.Response[featureflag.ResolveIntResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("featureflag.FeatureFlagService.ResolveInt is not implemented"))
}

func (UnimplementedFeatureFlagServiceHandler) ResolveObject(context.Context, *connect.Request[featureflag.ResolveObjectRequest]) (*connect.Response[featureflag.ResolveObjectResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("featureflag.FeatureFlagService.ResolveObject is not implemented"))
}
