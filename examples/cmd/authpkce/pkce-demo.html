<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PKCE Demo - Keycloak Localhost</title>
  <style>
    body { font-family: sans-serif; margin: 2em; }
    input, button { margin: 0.5em 0; }
    pre { background: #f4f4f4; padding: 1em; white-space: pre-wrap; word-break: break-word; }
    .token { word-break: break-all; }
    .section { margin-bottom: 2em; }
    .endpoint-btn { margin-right: 1em; }
    #endpoint-result { max-width: 100%; overflow-x: auto; }
  </style>
  <script>
    // Global constants for easy tweaking
    const AUTO_REFRESH_THRESHOLD_MS = 4 * 60 * 1000; // 4 minutes before expiry
    const EXPIRY_TIMER_INTERVAL_MS = 1000;   // Timer update interval
  </script>
</head>
<body>
  <h1>PKCE OAuth2 Demo (Keycloak @ localhost:8888)</h1>
  <div class="section">
    <div>
      <button id="login">Login</button>
      <span id="login-status"></span>
    </div>
    <div style="margin-top:0.5em;">
      <span id="token-expiry-timer"></span>
      <label style="margin-left:1em;"><input type="checkbox" id="auto-refresh-token" checked> Auto-refresh token</label>
      <button id="logout" style="display:none; margin-left:1em;">Logout</button>
      <button id="refresh-token" style="display:none">Refresh Token</button>
    </div>
    <div style="margin-top:0.5em;">
      <span id="user-info"></span>
    </div>
  </div>
  <div class="section" id="userinfo-section" style="display:none">
    <h2>UserInfo</h2>
    <button id="fetch-userinfo">Fetch UserInfo</button>
    <pre id="userinfo"></pre>
  </div>
  <div class="section" id="endpoints-section" style="display:none">
    <h2>Quick Endpoint Tests</h2>
    <button class="endpoint-btn" id="write-namespace-btn" data-url="__PLATFORM_ENDPOINT__/policy.namespaces.NamespaceService/CreateNamespace" data-method="POST">Admin Role: Create Random Namespace</button>
    <button class="endpoint-btn" id="read-namespaces-btn" data-url="__PLATFORM_ENDPOINT__/policy.namespaces.NamespaceService/ListNamespaces" data-method="POST" data-body="{}">Standard Role: List Namespaces</button>
    <button class="endpoint-btn" id="rewrap-unknown-btn" data-url="__PLATFORM_ENDPOINT__/kas.AccessService/Rewrap" data-method="POST" data-body="{}">Unknown Role: Read KAS ReWrap</button>
    <pre id="endpoint-result"></pre>
  </div>
  <div class="section" id="tokens-section">
    <h2>Tokens</h2>
    <pre id="tokens"></pre>
  </div>
  <script>
    // PKCE OAuth2 Demo JS (injected config)
    const config = {
      ...__PLATFORM_WELLKNOWN_CONFIG__,
      clientId: '__CLIENT_ID__',
      scope: '__SCOPE__',
      platformEndpoint: '__PLATFORM_ENDPOINT__',
      redirectUri: window.location.origin + window.location.pathname,
    };
    // Use OIDC standard keys from config
    config.authUrl = config.authorization_endpoint;
    config.tokenUrl = config.token_endpoint;
    config.userinfoUrl = config.userinfo_endpoint;
    config.logoutUrl = config.end_session_endpoint;
    // PKCE helpers
    function base64urlencode(a) {
      return btoa(String.fromCharCode.apply(null, new Uint8Array(a)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }
    async function sha256(str) {
      const buf = new TextEncoder().encode(str);
      const hash = await window.crypto.subtle.digest('SHA-256', buf);
      return base64urlencode(hash);
    }
    function randomString(len) {
      const arr = new Uint8Array(len);
      window.crypto.getRandomValues(arr);
      return Array.from(arr).map(x => ('0' + x.toString(16)).slice(-2)).join('');
    }
    // State
    let codeVerifier = null;
    let tokens = null;
    // UI
    const loginBtn = document.getElementById('login');
    const logoutBtn = document.getElementById('logout');
    const refreshTokenBtn = document.getElementById('refresh-token');
    const loginStatus = document.getElementById('login-status');
    const userinfoSection = document.getElementById('userinfo-section');
    const fetchUserinfoBtn = document.getElementById('fetch-userinfo');
    const userinfoPre = document.getElementById('userinfo');
    const endpointsSection = document.getElementById('endpoints-section');
    const endpointBtns = document.querySelectorAll('.endpoint-btn');
    const endpointResult = document.getElementById('endpoint-result');
    const tokensPre = document.getElementById('tokens');
    const autoRefreshCheckbox = document.getElementById('auto-refresh-token');
    // --- Token Expiry Timer and Auto-Refresh ---
    let expiryTimerInterval = null;
    let autoRefreshEnabled = autoRefreshCheckbox.checked;
    const tokenExpiryTimer = document.getElementById('token-expiry-timer');

    function getAccessTokenExpiry() {
      if (!tokens || !tokens.access_token) return null;
      const at = parseJwt(tokens.access_token);
      if (!at.exp) return null;
      return at.exp * 1000; // exp is in seconds
    }

    function updateTokenExpiryTimer() {
      const expiry = getAccessTokenExpiry();
      if (!expiry) {
        tokenExpiryTimer.textContent = '';
        return;
      }
      const now = Date.now();
      let seconds = Math.max(0, Math.floor((expiry - now) / 1000));
      let min = Math.floor(seconds / 60);
      let sec = seconds % 60;
      tokenExpiryTimer.textContent = `Access token expires in: ${min}:${sec.toString().padStart(2, '0')}`;
    }

    function startExpiryTimer() {
      if (expiryTimerInterval) clearInterval(expiryTimerInterval);
      updateTokenExpiryTimer();
      expiryTimerInterval = setInterval(() => {
        updateTokenExpiryTimer();
        if (autoRefreshEnabled) {
          const expiry = getAccessTokenExpiry();
          if (expiry && expiry - Date.now() < AUTO_REFRESH_THRESHOLD_MS) {
            refreshToken();
          }
        }
      }, EXPIRY_TIMER_INTERVAL_MS);
    }
    function stopExpiryTimer() {
      if (expiryTimerInterval) clearInterval(expiryTimerInterval);
      tokenExpiryTimer.textContent = '';
    }
    autoRefreshCheckbox.onchange = function() {
      autoRefreshEnabled = autoRefreshCheckbox.checked;
    };
    // Main
    function showTokens() {
      if (!tokens) {
        tokensPre.innerHTML = '';
        return;
      }
      // Prepare token values and decoded JWTs
      const accessToken = tokens.access_token || '';
      const idToken = tokens.id_token || '';
      const refreshToken = tokens.refresh_token || '';
      let accessJwt = '';
      let idJwt = '';
      try {
        accessJwt = accessToken ? JSON.stringify(parseJwt(accessToken), null, 2) : '';
      } catch (e) {
        accessJwt = 'Invalid JWT';
      }
      try {
        idJwt = idToken ? JSON.stringify(parseJwt(idToken), null, 2) : '';
      } catch (e) {
        idJwt = 'Invalid JWT';
      }
      // Layout: 3 columns for easy comparison
      tokensPre.innerHTML = `
        <div style="display: flex; gap: 1em; flex-wrap: wrap;">
          <div style="flex:1; min-width: 250px;">
            <b>Access Token</b>
            <pre class="token">${accessToken}</pre>
            <details open><summary>Decoded JWT</summary><pre>${accessJwt}</pre></details>
          </div>
          <div style="flex:1; min-width: 250px;">
            <b>ID Token</b>
            <pre class="token">${idToken}</pre>
            <details open><summary>Decoded JWT</summary><pre>${idJwt}</pre></details>
          </div>
          <div style="flex:1; min-width: 250px;">
            <b>Refresh Token</b>
            <pre class="token">${refreshToken}</pre>
          </div>
        </div>
      `;
      startExpiryTimer();
    }
    // Helper to decode JWT
    function parseJwt(token) {
      if (!token) return {};
      const base64Url = token.split('.')[1];
      if (!base64Url) return {};
      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
      return JSON.parse(jsonPayload);
    }
    function showUserInfo() {
      let html = '';
      if (tokens && tokens.id_token) {
        const idt = parseJwt(tokens.id_token);
        if (idt.email) html += ' | <b>Email:</b> ' + idt.email;
        if (idt.preferred_username) html += ' | <b>User:</b> ' + idt.preferred_username;
      }
      if (tokens && tokens.access_token) {
        const at = parseJwt(tokens.access_token);
        if (at.sub) html += ' | <b>Sub:</b> ' + at.sub;
      }
      document.getElementById('user-info').innerHTML = html;
    }
    function setLoggedIn(loggedIn) {
      loginBtn.style.display = loggedIn ? 'none' : '';
      logoutBtn.style.display = loggedIn ? '' : 'none';
      refreshTokenBtn.style.display = loggedIn ? '' : 'none';
      loginStatus.textContent = loggedIn ? 'Logged in' : 'Not logged in';
      // Show/hide token expiry and auto-refresh inline with status
      tokenExpiryTimer.style.display = loggedIn ? '' : 'none';
      autoRefreshCheckbox.parentElement.style.display = loggedIn ? '' : 'none';
      userinfoSection.style.display = loggedIn ? '' : 'none';
      endpointsSection.style.display = loggedIn ? '' : 'none';
      showTokens();
      showUserInfo();
      if (loggedIn) {
        startExpiryTimer();
      } else {
        stopExpiryTimer();
      }
    }
    function clearTokens() {
      tokens = null;
      localStorage.removeItem('pkce_tokens');
      showTokens();
      stopExpiryTimer();
    }
    function saveTokens(t) {
      tokens = t;
      localStorage.setItem('pkce_tokens', JSON.stringify(tokens));
      showTokens();
    }
    function loadTokens() {
      const t = localStorage.getItem('pkce_tokens');
      if (t) tokens = JSON.parse(t);
      showTokens();
    }
    async function login() {
      codeVerifier = randomString(64);
      localStorage.setItem('pkce_code_verifier', codeVerifier);
      const codeChallenge = await sha256(codeVerifier);
      const params = [
        'response_type=code',
        'client_id=' + encodeURIComponent(config.clientId),
        'redirect_uri=' + encodeURIComponent(config.redirectUri),
        'scope=' + encodeURIComponent(config.scope),
        'code_challenge=' + encodeURIComponent(codeChallenge),
        'code_challenge_method=S256'
      ].join('&');
      window.location = config.authUrl + '?' + params;
    }
    async function handleRedirect() {
      const url = new URL(window.location.href);
      const code = url.searchParams.get('code');
      if (!code) return false;
      codeVerifier = localStorage.getItem('pkce_code_verifier');
      if (!codeVerifier) return false;
      // Exchange code for tokens
      const body = [
        'grant_type=authorization_code',
        'client_id=' + encodeURIComponent(config.clientId),
        'code_verifier=' + encodeURIComponent(codeVerifier),
        'code=' + encodeURIComponent(code),
        'redirect_uri=' + encodeURIComponent(config.redirectUri)
      ].join('&');
      const resp = await fetch(config.tokenUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body
      });
      const data = await resp.json();
      if (data.access_token) {
        saveTokens(data);
        window.history.replaceState({}, '', config.redirectUri);
        setLoggedIn(true);
      } else {
        alert('Token exchange failed: ' + JSON.stringify(data));
      }
      return true;
    }
    async function fetchUserinfo() {
      if (!tokens || !tokens.access_token) return;
      const resp = await fetch(config.userinfoUrl, {
        headers: { 'Authorization': 'Bearer ' + tokens.access_token }
      });
      const data = await resp.json();
      userinfoPre.textContent = JSON.stringify(data, null, 2);
    }
    async function refreshToken() {
      if (!tokens || !tokens.refresh_token) {
        alert('No refresh token available.');
        return;
      }
      const body = [
        'grant_type=refresh_token',
        'client_id=' + encodeURIComponent(config.clientId),
        'refresh_token=' + encodeURIComponent(tokens.refresh_token)
      ].join('&');
      try {
        const resp = await fetch(config.tokenUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body
        });
        const data = await resp.json();
        if (data.access_token) {
          // Preserve the old refresh token if not returned
          if (!data.refresh_token && tokens.refresh_token) {
            data.refresh_token = tokens.refresh_token;
          }
          saveTokens(data);
          setLoggedIn(true);
        } else {
          alert('Token refresh failed: ' + JSON.stringify(data));
        }
      } catch (e) {
        alert('Token refresh error: ' + e);
      }
    }
    async function logout() {
      clearTokens();
      setLoggedIn(false);
      stopExpiryTimer();
      // Open logout in a new window/tab (no redirect_uri)
      window.open(config.logoutUrl, '_blank', 'noopener,noreferrer,width=500,height=600');
      // Hide introspection result on logout
      document.getElementById('introspection-result').style.display = 'none';
      // Optionally, show a message or reload the page
    }
    // Event listeners
    loginBtn.onclick = login;
    logoutBtn.onclick = logout;
    fetchUserinfoBtn.onclick = fetchUserinfo;
    refreshTokenBtn.onclick = refreshToken;
    endpointBtns.forEach(btn => {
      btn.onclick = () => callEndpoint(btn.getAttribute('data-url'), btn.getAttribute('data-method'));
    });
    // Patch endpoint button URLs at runtime
    document.addEventListener('DOMContentLoaded', function() {
      document.querySelectorAll('.endpoint-btn').forEach(btn => {
        btn.setAttribute('data-url', btn.getAttribute('data-url').replace('__PLATFORM_ENDPOINT__', config.platformEndpoint));
      });
    });
    // Init
    (async function() {
      loadTokens();
      if (await handleRedirect()) return;
      setLoggedIn(!!tokens && !!tokens.access_token);
    })();
  </script>
</body>
</html>
