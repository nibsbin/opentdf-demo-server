// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: obligations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createObligationByNamespaceFQN = `-- name: createObligationByNamespaceFQN :one
INSERT INTO obligation_definitions (namespace_id, name, metadata)
SELECT fqns.namespace_id, $2, $3
FROM attribute_fqns fqns
WHERE fqns.fqn = $1
RETURNING id
`

type createObligationByNamespaceFQNParams struct {
	Fqn      string `json:"fqn"`
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
}

// createObligationByNamespaceFQN
//
//	INSERT INTO obligation_definitions (namespace_id, name, metadata)
//	SELECT fqns.namespace_id, $2, $3
//	FROM attribute_fqns fqns
//	WHERE fqns.fqn = $1
//	RETURNING id
func (q *Queries) createObligationByNamespaceFQN(ctx context.Context, arg createObligationByNamespaceFQNParams) (string, error) {
	row := q.db.QueryRow(ctx, createObligationByNamespaceFQN, arg.Fqn, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createObligationByNamespaceId = `-- name: createObligationByNamespaceId :one

INSERT INTO obligation_definitions (namespace_id, name, metadata)
VALUES ($1, $2, $3)
RETURNING id
`

type createObligationByNamespaceIdParams struct {
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
}

// --------------------------------------------------------------
// OBLIGATIONS
// --------------------------------------------------------------
//
//	INSERT INTO obligation_definitions (namespace_id, name, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) createObligationByNamespaceId(ctx context.Context, arg createObligationByNamespaceIdParams) (string, error) {
	row := q.db.QueryRow(ctx, createObligationByNamespaceId, arg.NamespaceID, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteObligationDefinition = `-- name: deleteObligationDefinition :execrows
DELETE FROM obligation_definitions WHERE id = $1
`

// deleteObligationDefinition
//
//	DELETE FROM obligation_definitions WHERE id = $1
func (q *Queries) deleteObligationDefinition(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteObligationDefinition, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getObligationDefinition = `-- name: getObligationDefinition :one
SELECT
    od.id,
    od.name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name
    ) as namespace,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', ov.id,
            'value', ov.value
        )
    ) FILTER (WHERE ov.id IS NOT NULL) as values
    -- todo: add triggers and fulfillers
FROM obligation_definitions od
JOIN attribute_namespaces n on od.namespace_id = n.id
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
WHERE
    -- handles by id or fqn queries
    (NULLIF($1, '') IS NULL OR id = $1::UUID) AND
    (NULLIF($2, '') IS NULL OR od.namespace_id = $2::UUID) AND
    (NULLIF($3, '') IS NULL OR name = $3::VARCHAR)
GROUP BY od.id, n.id
`

type getObligationDefinitionParams struct {
	ID          interface{} `json:"id"`
	NamespaceID interface{} `json:"namespace_id"`
	Name        interface{} `json:"name"`
}

type getObligationDefinitionRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Namespace []byte `json:"namespace"`
	Metadata  []byte `json:"metadata"`
	Values    []byte `json:"values"`
}

// getObligationDefinition
//
//	SELECT
//	    od.id,
//	    od.name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name
//	    ) as namespace,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', ov.id,
//	            'value', ov.value
//	        )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values
//	    -- todo: add triggers and fulfillers
//	FROM obligation_definitions od
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	WHERE
//	    -- handles by id or fqn queries
//	    (NULLIF($1, '') IS NULL OR id = $1::UUID) AND
//	    (NULLIF($2, '') IS NULL OR od.namespace_id = $2::UUID) AND
//	    (NULLIF($3, '') IS NULL OR name = $3::VARCHAR)
//	GROUP BY od.id, n.id
func (q *Queries) getObligationDefinition(ctx context.Context, arg getObligationDefinitionParams) (getObligationDefinitionRow, error) {
	row := q.db.QueryRow(ctx, getObligationDefinition, arg.ID, arg.NamespaceID, arg.Name)
	var i getObligationDefinitionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Namespace,
		&i.Metadata,
		&i.Values,
	)
	return i, err
}

const listObligationDefinitions = `-- name: listObligationDefinitions :many
WITH counted AS (
    SELECT COUNT(id) AS total
    FROM obligation_definitions
    WHERE
        (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
)
SELECT
    od.id,
    od.name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name
    ) as namespace,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', ov.id,
            'value', ov.value
        )
    ) FILTER (WHERE ov.id IS NOT NULL) as values,
    -- todo: add triggers and fulfillers
    counted.total
FROM obligation_definitions od
JOIN attribute_namespaces n on od.namespace_id = n.id
CROSS JOIN counted
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
WHERE
    (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
GROUP BY od.id, n.id, counted.total
LIMIT $3
OFFSET $2
`

type listObligationDefinitionsParams struct {
	NamespaceID interface{} `json:"namespace_id"`
	Offset      int32       `json:"offset_"`
	Limit       int32       `json:"limit_"`
}

type listObligationDefinitionsRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Namespace []byte `json:"namespace"`
	Metadata  []byte `json:"metadata"`
	Values    []byte `json:"values"`
	Total     int64  `json:"total"`
}

// listObligationDefinitions
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total
//	    FROM obligation_definitions
//	    WHERE
//	        (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
//	)
//	SELECT
//	    od.id,
//	    od.name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name
//	    ) as namespace,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', ov.id,
//	            'value', ov.value
//	        )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values,
//	    -- todo: add triggers and fulfillers
//	    counted.total
//	FROM obligation_definitions od
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	CROSS JOIN counted
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	WHERE
//	    (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
//	GROUP BY od.id, n.id, counted.total
//	LIMIT $3
//	OFFSET $2
func (q *Queries) listObligationDefinitions(ctx context.Context, arg listObligationDefinitionsParams) ([]listObligationDefinitionsRow, error) {
	rows, err := q.db.Query(ctx, listObligationDefinitions, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listObligationDefinitionsRow
	for rows.Next() {
		var i listObligationDefinitionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Namespace,
			&i.Metadata,
			&i.Values,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObligationDefinition = `-- name: updateObligationDefinition :execrows
UPDATE obligation_definitions
SET
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type updateObligationDefinitionParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	Metadata []byte      `json:"metadata"`
}

// updateObligationDefinition
//
//	UPDATE obligation_definitions
//	SET
//	    name = COALESCE($2, name),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) updateObligationDefinition(ctx context.Context, arg updateObligationDefinitionParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateObligationDefinition, arg.ID, arg.Name, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
