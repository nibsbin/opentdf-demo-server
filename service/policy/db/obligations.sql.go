// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: obligations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createObligationByNamespaceFQN = `-- name: createObligationByNamespaceFQN :one
WITH inserted_obligation AS (
    INSERT INTO obligation_definitions (namespace_id, name, metadata)
    SELECT fqns.namespace_id, $2, $3
    FROM attribute_fqns fqns
    WHERE fqns.fqn = $1
    RETURNING id, namespace_id, name, metadata
),
inserted_values AS (
    INSERT INTO obligation_values_standard (obligation_definition_id, value)
    SELECT io.id, UNNEST($4::VARCHAR[])
    FROM inserted_obligation io
    WHERE $4::VARCHAR[] IS NOT NULL AND array_length($4::VARCHAR[], 1) > 0
    RETURNING id, obligation_definition_id, value
)
SELECT
    io.id,
    io.name,
    io.metadata,
    JSON_BUILD_OBJECT(
        'id', ns.id,
        'name', ns.name,
        'active', ns.active,
        'fqn', fqns.fqn,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)),
        'grants', JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT(
            'id', kas.id,
            'uri', kas.uri,
            'name', kas.name,
            'public_key', kas.public_key
        )) FILTER (WHERE kas_ns_grants.namespace_id IS NOT NULL),
        'keys', nmp_keys.keys
    ) as namespace,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', iv.id,
                'value', iv.value
            )
        ) FILTER (WHERE iv.id IS NOT NULL),
        '[]'::JSON
    ) as values
FROM inserted_obligation io
JOIN attribute_namespaces ns ON io.namespace_id = ns.id
LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
LEFT JOIN inserted_values iv ON iv.obligation_definition_id = io.id
LEFT JOIN (
    SELECT
        k.namespace_id,
        JSONB_AGG(
            DISTINCT JSONB_BUILD_OBJECT(
                'kas_uri', kas.uri,
                'kas_id', kas.id,
                'public_key', JSONB_BUILD_OBJECT(
                     'algorithm', kask.key_algorithm::INTEGER,
                     'kid', kask.key_id,
                     'pem', CONVERT_FROM(DECODE(kask.public_key_ctx ->> 'pem', 'base64'), 'UTF8')
                )
            )
        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
    FROM attribute_namespace_public_key_map k
    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
    GROUP BY k.namespace_id
) nmp_keys ON ns.id = nmp_keys.namespace_id
WHERE fqns.attribute_id IS NULL AND fqns.value_id IS NULL
GROUP BY io.id, io.name, io.metadata, ns.id, ns.name, ns.active, ns.metadata, ns.created_at, ns.updated_at, fqns.fqn, nmp_keys.keys
`

type createObligationByNamespaceFQNParams struct {
	Fqn      string   `json:"fqn"`
	Name     string   `json:"name"`
	Metadata []byte   `json:"metadata"`
	Column4  []string `json:"column_4"`
}

type createObligationByNamespaceFQNRow struct {
	ID        string      `json:"id"`
	Name      string      `json:"name"`
	Metadata  []byte      `json:"metadata"`
	Namespace []byte      `json:"namespace"`
	Values    interface{} `json:"values"`
}

// createObligationByNamespaceFQN
//
//	WITH inserted_obligation AS (
//	    INSERT INTO obligation_definitions (namespace_id, name, metadata)
//	    SELECT fqns.namespace_id, $2, $3
//	    FROM attribute_fqns fqns
//	    WHERE fqns.fqn = $1
//	    RETURNING id, namespace_id, name, metadata
//	),
//	inserted_values AS (
//	    INSERT INTO obligation_values_standard (obligation_definition_id, value)
//	    SELECT io.id, UNNEST($4::VARCHAR[])
//	    FROM inserted_obligation io
//	    WHERE $4::VARCHAR[] IS NOT NULL AND array_length($4::VARCHAR[], 1) > 0
//	    RETURNING id, obligation_definition_id, value
//	)
//	SELECT
//	    io.id,
//	    io.name,
//	    io.metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', ns.id,
//	        'name', ns.name,
//	        'active', ns.active,
//	        'fqn', fqns.fqn,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)),
//	        'grants', JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	            'id', kas.id,
//	            'uri', kas.uri,
//	            'name', kas.name,
//	            'public_key', kas.public_key
//	        )) FILTER (WHERE kas_ns_grants.namespace_id IS NOT NULL),
//	        'keys', nmp_keys.keys
//	    ) as namespace,
//	    COALESCE(
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', iv.id,
//	                'value', iv.value
//	            )
//	        ) FILTER (WHERE iv.id IS NOT NULL),
//	        '[]'::JSON
//	    ) as values
//	FROM inserted_obligation io
//	JOIN attribute_namespaces ns ON io.namespace_id = ns.id
//	LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
//	LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
//	LEFT JOIN inserted_values iv ON iv.obligation_definition_id = io.id
//	LEFT JOIN (
//	    SELECT
//	        k.namespace_id,
//	        JSONB_AGG(
//	            DISTINCT JSONB_BUILD_OBJECT(
//	                'kas_uri', kas.uri,
//	                'kas_id', kas.id,
//	                'public_key', JSONB_BUILD_OBJECT(
//	                     'algorithm', kask.key_algorithm::INTEGER,
//	                     'kid', kask.key_id,
//	                     'pem', CONVERT_FROM(DECODE(kask.public_key_ctx ->> 'pem', 'base64'), 'UTF8')
//	                )
//	            )
//	        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
//	    FROM attribute_namespace_public_key_map k
//	    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	    GROUP BY k.namespace_id
//	) nmp_keys ON ns.id = nmp_keys.namespace_id
//	WHERE fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	GROUP BY io.id, io.name, io.metadata, ns.id, ns.name, ns.active, ns.metadata, ns.created_at, ns.updated_at, fqns.fqn, nmp_keys.keys
func (q *Queries) createObligationByNamespaceFQN(ctx context.Context, arg createObligationByNamespaceFQNParams) (createObligationByNamespaceFQNRow, error) {
	row := q.db.QueryRow(ctx, createObligationByNamespaceFQN,
		arg.Fqn,
		arg.Name,
		arg.Metadata,
		arg.Column4,
	)
	var i createObligationByNamespaceFQNRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Metadata,
		&i.Namespace,
		&i.Values,
	)
	return i, err
}

const createObligationByNamespaceID = `-- name: createObligationByNamespaceID :one

WITH inserted_obligation AS (
    INSERT INTO obligation_definitions (namespace_id, name, metadata)
    VALUES ($1, $2, $3)
    RETURNING id, namespace_id, name, metadata
),
inserted_values AS (
    INSERT INTO obligation_values_standard (obligation_definition_id, value)
    SELECT io.id, UNNEST($4::VARCHAR[])
    FROM inserted_obligation io
    WHERE $4::VARCHAR[] IS NOT NULL AND array_length($4::VARCHAR[], 1) > 0
    RETURNING id, obligation_definition_id, value
)
SELECT
    io.id,
    io.name,
    io.metadata,
    JSON_BUILD_OBJECT(
        'id', ns.id,
        'name', ns.name,
        'active', ns.active,
        'fqn', fqns.fqn,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)),
        'grants', JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT(
            'id', kas.id,
            'uri', kas.uri,
            'name', kas.name,
            'public_key', kas.public_key
        )) FILTER (WHERE kas_ns_grants.namespace_id IS NOT NULL),
        'keys', nmp_keys.keys
    ) as namespace,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', iv.id,
                'value', iv.value
            )
        ) FILTER (WHERE iv.id IS NOT NULL),
        '[]'::JSON
    ) as values
FROM inserted_obligation io
JOIN attribute_namespaces ns ON io.namespace_id = ns.id
LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
LEFT JOIN inserted_values iv ON iv.obligation_definition_id = io.id
LEFT JOIN (
    SELECT
        k.namespace_id,
        JSONB_AGG(
            DISTINCT JSONB_BUILD_OBJECT(
                'kas_uri', kas.uri,
                'kas_id', kas.id,
                'public_key', JSONB_BUILD_OBJECT(
                     'algorithm', kask.key_algorithm::INTEGER,
                     'kid', kask.key_id,
                     'pem', CONVERT_FROM(DECODE(kask.public_key_ctx ->> 'pem', 'base64'), 'UTF8')
                )
            )
        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
    FROM attribute_namespace_public_key_map k
    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
    GROUP BY k.namespace_id
) nmp_keys ON ns.id = nmp_keys.namespace_id
WHERE fqns.attribute_id IS NULL AND fqns.value_id IS NULL
GROUP BY io.id, io.name, io.metadata, ns.id, ns.name, ns.active, ns.metadata, ns.created_at, ns.updated_at, fqns.fqn, nmp_keys.keys
`

type createObligationByNamespaceIDParams struct {
	NamespaceID string   `json:"namespace_id"`
	Name        string   `json:"name"`
	Metadata    []byte   `json:"metadata"`
	Column4     []string `json:"column_4"`
}

type createObligationByNamespaceIDRow struct {
	ID        string      `json:"id"`
	Name      string      `json:"name"`
	Metadata  []byte      `json:"metadata"`
	Namespace []byte      `json:"namespace"`
	Values    interface{} `json:"values"`
}

// --------------------------------------------------------------
// OBLIGATIONS
// --------------------------------------------------------------
//
//	WITH inserted_obligation AS (
//	    INSERT INTO obligation_definitions (namespace_id, name, metadata)
//	    VALUES ($1, $2, $3)
//	    RETURNING id, namespace_id, name, metadata
//	),
//	inserted_values AS (
//	    INSERT INTO obligation_values_standard (obligation_definition_id, value)
//	    SELECT io.id, UNNEST($4::VARCHAR[])
//	    FROM inserted_obligation io
//	    WHERE $4::VARCHAR[] IS NOT NULL AND array_length($4::VARCHAR[], 1) > 0
//	    RETURNING id, obligation_definition_id, value
//	)
//	SELECT
//	    io.id,
//	    io.name,
//	    io.metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', ns.id,
//	        'name', ns.name,
//	        'active', ns.active,
//	        'fqn', fqns.fqn,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)),
//	        'grants', JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	            'id', kas.id,
//	            'uri', kas.uri,
//	            'name', kas.name,
//	            'public_key', kas.public_key
//	        )) FILTER (WHERE kas_ns_grants.namespace_id IS NOT NULL),
//	        'keys', nmp_keys.keys
//	    ) as namespace,
//	    COALESCE(
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', iv.id,
//	                'value', iv.value
//	            )
//	        ) FILTER (WHERE iv.id IS NOT NULL),
//	        '[]'::JSON
//	    ) as values
//	FROM inserted_obligation io
//	JOIN attribute_namespaces ns ON io.namespace_id = ns.id
//	LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
//	LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
//	LEFT JOIN inserted_values iv ON iv.obligation_definition_id = io.id
//	LEFT JOIN (
//	    SELECT
//	        k.namespace_id,
//	        JSONB_AGG(
//	            DISTINCT JSONB_BUILD_OBJECT(
//	                'kas_uri', kas.uri,
//	                'kas_id', kas.id,
//	                'public_key', JSONB_BUILD_OBJECT(
//	                     'algorithm', kask.key_algorithm::INTEGER,
//	                     'kid', kask.key_id,
//	                     'pem', CONVERT_FROM(DECODE(kask.public_key_ctx ->> 'pem', 'base64'), 'UTF8')
//	                )
//	            )
//	        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
//	    FROM attribute_namespace_public_key_map k
//	    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	    GROUP BY k.namespace_id
//	) nmp_keys ON ns.id = nmp_keys.namespace_id
//	WHERE fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	GROUP BY io.id, io.name, io.metadata, ns.id, ns.name, ns.active, ns.metadata, ns.created_at, ns.updated_at, fqns.fqn, nmp_keys.keys
func (q *Queries) createObligationByNamespaceID(ctx context.Context, arg createObligationByNamespaceIDParams) (createObligationByNamespaceIDRow, error) {
	row := q.db.QueryRow(ctx, createObligationByNamespaceID,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
		arg.Column4,
	)
	var i createObligationByNamespaceIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Metadata,
		&i.Namespace,
		&i.Values,
	)
	return i, err
}

const deleteObligationDefinition = `-- name: deleteObligationDefinition :execrows
DELETE FROM obligation_definitions WHERE id = $1
`

// deleteObligationDefinition
//
//	DELETE FROM obligation_definitions WHERE id = $1
func (q *Queries) deleteObligationDefinition(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteObligationDefinition, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getObligationDefinition = `-- name: getObligationDefinition :one
SELECT
    od.id,
    od.name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name
    ) as namespace,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', ov.id,
            'value', ov.value
        )
    ) FILTER (WHERE ov.id IS NOT NULL) as values
    -- todo: add triggers and fulfillers
FROM obligation_definitions od
JOIN attribute_namespaces n on od.namespace_id = n.id
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
WHERE
    -- handles by id or fqn queries
    (NULLIF($1, '') IS NULL OR id = $1::UUID) AND
    (NULLIF($2, '') IS NULL OR od.namespace_id = $2::UUID) AND
    (NULLIF($3, '') IS NULL OR name = $3::VARCHAR)
GROUP BY od.id, n.id
`

type getObligationDefinitionParams struct {
	ID          interface{} `json:"id"`
	NamespaceID interface{} `json:"namespace_id"`
	Name        interface{} `json:"name"`
}

type getObligationDefinitionRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Namespace []byte `json:"namespace"`
	Metadata  []byte `json:"metadata"`
	Values    []byte `json:"values"`
}

// getObligationDefinition
//
//	SELECT
//	    od.id,
//	    od.name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name
//	    ) as namespace,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', ov.id,
//	            'value', ov.value
//	        )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values
//	    -- todo: add triggers and fulfillers
//	FROM obligation_definitions od
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	WHERE
//	    -- handles by id or fqn queries
//	    (NULLIF($1, '') IS NULL OR id = $1::UUID) AND
//	    (NULLIF($2, '') IS NULL OR od.namespace_id = $2::UUID) AND
//	    (NULLIF($3, '') IS NULL OR name = $3::VARCHAR)
//	GROUP BY od.id, n.id
func (q *Queries) getObligationDefinition(ctx context.Context, arg getObligationDefinitionParams) (getObligationDefinitionRow, error) {
	row := q.db.QueryRow(ctx, getObligationDefinition, arg.ID, arg.NamespaceID, arg.Name)
	var i getObligationDefinitionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Namespace,
		&i.Metadata,
		&i.Values,
	)
	return i, err
}

const listObligationDefinitions = `-- name: listObligationDefinitions :many
WITH counted AS (
    SELECT COUNT(id) AS total
    FROM obligation_definitions
    WHERE
        (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
)
SELECT
    od.id,
    od.name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name
    ) as namespace,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', ov.id,
            'value', ov.value
        )
    ) FILTER (WHERE ov.id IS NOT NULL) as values,
    -- todo: add triggers and fulfillers
    counted.total
FROM obligation_definitions od
JOIN attribute_namespaces n on od.namespace_id = n.id
CROSS JOIN counted
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
WHERE
    (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
GROUP BY od.id, n.id, counted.total
LIMIT $3
OFFSET $2
`

type listObligationDefinitionsParams struct {
	NamespaceID interface{} `json:"namespace_id"`
	Offset      int32       `json:"offset_"`
	Limit       int32       `json:"limit_"`
}

type listObligationDefinitionsRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Namespace []byte `json:"namespace"`
	Metadata  []byte `json:"metadata"`
	Values    []byte `json:"values"`
	Total     int64  `json:"total"`
}

// listObligationDefinitions
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total
//	    FROM obligation_definitions
//	    WHERE
//	        (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
//	)
//	SELECT
//	    od.id,
//	    od.name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name
//	    ) as namespace,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', ov.id,
//	            'value', ov.value
//	        )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values,
//	    -- todo: add triggers and fulfillers
//	    counted.total
//	FROM obligation_definitions od
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	CROSS JOIN counted
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	WHERE
//	    (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
//	GROUP BY od.id, n.id, counted.total
//	LIMIT $3
//	OFFSET $2
func (q *Queries) listObligationDefinitions(ctx context.Context, arg listObligationDefinitionsParams) ([]listObligationDefinitionsRow, error) {
	rows, err := q.db.Query(ctx, listObligationDefinitions, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listObligationDefinitionsRow
	for rows.Next() {
		var i listObligationDefinitionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Namespace,
			&i.Metadata,
			&i.Values,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObligationDefinition = `-- name: updateObligationDefinition :execrows
UPDATE obligation_definitions
SET
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type updateObligationDefinitionParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	Metadata []byte      `json:"metadata"`
}

// updateObligationDefinition
//
//	UPDATE obligation_definitions
//	SET
//	    name = COALESCE($2, name),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) updateObligationDefinition(ctx context.Context, arg updateObligationDefinitionParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateObligationDefinition, arg.ID, arg.Name, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
