// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: obligations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createObligationDefinition = `-- name: createObligationDefinition :one

INSERT INTO obligation_definitions (namespace_id, name, metadata)
VALUES ($1, $2, $3)
RETURNING id
`

type createObligationDefinitionParams struct {
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
}

// --------------------------------------------------------------
// OBLIGATIONS
// --------------------------------------------------------------
//
//	INSERT INTO obligation_definitions (namespace_id, name, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) createObligationDefinition(ctx context.Context, arg createObligationDefinitionParams) (string, error) {
	row := q.db.QueryRow(ctx, createObligationDefinition, arg.NamespaceID, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteObligationDefinition = `-- name: deleteObligationDefinition :execrows
DELETE FROM obligation_definitions WHERE id = $1
`

// deleteObligationDefinition
//
//	DELETE FROM obligation_definitions WHERE id = $1
func (q *Queries) deleteObligationDefinition(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteObligationDefinition, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getObligationDefinition = `-- name: getObligationDefinition :one
SELECT
    od.id,
    od.name,
    -- todo: prob return this as a JSON object
    od.namespace_id,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
    JSON_BUILD_OBJECT(
        'id', ov.id,
        'value', ov.value
    )
    ) FILTER (WHERE ov.id IS NOT NULL) as values
    -- todo: add triggers and fulfillers
FROM obligation_definitions od
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
WHERE
    (NULLIF($1, '') IS NULL OR id = $1::UUID) AND
    (NULLIF($2, '') IS NULL OR name = $2::VARCHAR)
`

type getObligationDefinitionParams struct {
	ID   interface{} `json:"id"`
	Name interface{} `json:"name"`
}

type getObligationDefinitionRow struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	NamespaceID string `json:"namespace_id"`
	Metadata    []byte `json:"metadata"`
	Values      []byte `json:"values"`
}

// getObligationDefinition
//
//	SELECT
//	    od.id,
//	    od.name,
//	    -- todo: prob return this as a JSON object
//	    od.namespace_id,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	    JSON_BUILD_OBJECT(
//	        'id', ov.id,
//	        'value', ov.value
//	    )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values
//	    -- todo: add triggers and fulfillers
//	FROM obligation_definitions od
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	WHERE
//	    (NULLIF($1, '') IS NULL OR id = $1::UUID) AND
//	    (NULLIF($2, '') IS NULL OR name = $2::VARCHAR)
func (q *Queries) getObligationDefinition(ctx context.Context, arg getObligationDefinitionParams) (getObligationDefinitionRow, error) {
	row := q.db.QueryRow(ctx, getObligationDefinition, arg.ID, arg.Name)
	var i getObligationDefinitionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NamespaceID,
		&i.Metadata,
		&i.Values,
	)
	return i, err
}

const listObligationDefinitions = `-- name: listObligationDefinitions :many
WITH counted AS (
    SELECT COUNT(id) AS total
    FROM obligation_definitions
)
SELECT
    od.id,
    od.name,
    -- todo: prob return this as a JSON object
    od.namespace_id,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
    JSON_BUILD_OBJECT(
        'id', ov.id,
        'value', ov.value
    )
    ) FILTER (WHERE ov.id IS NOT NULL) as values,
    -- todo: add triggers and fulfillers
    counted.total
FROM obligation_definitions od
CROSS JOIN counted
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
WHERE
    (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
GROUP BY od.id, counted.total
LIMIT $3
OFFSET $2
`

type listObligationDefinitionsParams struct {
	NamespaceID interface{} `json:"namespace_id"`
	Offset      int32       `json:"offset_"`
	Limit       int32       `json:"limit_"`
}

type listObligationDefinitionsRow struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	NamespaceID string `json:"namespace_id"`
	Metadata    []byte `json:"metadata"`
	Values      []byte `json:"values"`
	Total       int64  `json:"total"`
}

// listObligationDefinitions
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total
//	    FROM obligation_definitions
//	)
//	SELECT
//	    od.id,
//	    od.name,
//	    -- todo: prob return this as a JSON object
//	    od.namespace_id,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	    JSON_BUILD_OBJECT(
//	        'id', ov.id,
//	        'value', ov.value
//	    )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values,
//	    -- todo: add triggers and fulfillers
//	    counted.total
//	FROM obligation_definitions od
//	CROSS JOIN counted
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	WHERE
//	    (NULLIF($1, '') IS NULL OR od.namespace_id = $1::UUID)
//	GROUP BY od.id, counted.total
//	LIMIT $3
//	OFFSET $2
func (q *Queries) listObligationDefinitions(ctx context.Context, arg listObligationDefinitionsParams) ([]listObligationDefinitionsRow, error) {
	rows, err := q.db.Query(ctx, listObligationDefinitions, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listObligationDefinitionsRow
	for rows.Next() {
		var i listObligationDefinitionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NamespaceID,
			&i.Metadata,
			&i.Values,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObligationDefinition = `-- name: updateObligationDefinition :execrows
UPDATE obligation_definitions
SET
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type updateObligationDefinitionParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	Metadata []byte      `json:"metadata"`
}

// updateObligationDefinition
//
//	UPDATE obligation_definitions
//	SET
//	    name = COALESCE($2, name),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) updateObligationDefinition(ctx context.Context, arg updateObligationDefinitionParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateObligationDefinition, arg.ID, arg.Name, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
