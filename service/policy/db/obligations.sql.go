// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: obligations.sql

package db

import (
	"context"
)

const createObligation = `-- name: createObligation :one

WITH inserted_obligation AS (
    INSERT INTO obligation_definitions (namespace_id, name, metadata)
    SELECT 
        CASE 
            WHEN $1::TEXT != '' THEN $1::UUID
            ELSE fqns.namespace_id
        END,
        $2, 
        $3
    FROM (
        SELECT 
            CASE 
                WHEN $1::TEXT != '' THEN $1::UUID
                ELSE NULL
            END as direct_namespace_id
    ) direct
    LEFT JOIN attribute_fqns fqns ON fqns.fqn = $4 AND $1::TEXT = ''
    WHERE 
        ($1::TEXT != '' AND direct.direct_namespace_id IS NOT NULL) OR
        ($4::TEXT != '' AND fqns.namespace_id IS NOT NULL)
    RETURNING id, namespace_id, name, metadata
),
inserted_values AS (
    INSERT INTO obligation_values_standard (obligation_definition_id, value)
    SELECT io.id, UNNEST($5::VARCHAR[])
    FROM inserted_obligation io
    WHERE $5::VARCHAR[] IS NOT NULL AND array_length($5::VARCHAR[], 1) > 0
    RETURNING id, obligation_definition_id, value
)
SELECT
    io.id,
    io.name,
    io.metadata,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', iv.id,
                'value', iv.value
            )
        ) FILTER (WHERE iv.id IS NOT NULL),
        '[]'::JSON
    )::JSONB as values
FROM inserted_obligation io
JOIN attribute_namespaces n ON io.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
LEFT JOIN inserted_values iv ON iv.obligation_definition_id = io.id
GROUP BY io.id, io.name, io.metadata, n.id, fqns.fqn
`

type createObligationParams struct {
	NamespaceID  string   `json:"namespace_id"`
	Name         string   `json:"name"`
	Metadata     []byte   `json:"metadata"`
	NamespaceFqn string   `json:"namespace_fqn"`
	Values       []string `json:"values"`
}

type createObligationRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Metadata  []byte `json:"metadata"`
	Namespace []byte `json:"namespace"`
	Values    []byte `json:"values"`
}

// --------------------------------------------------------------
// OBLIGATIONS
// --------------------------------------------------------------
//
//	WITH inserted_obligation AS (
//	    INSERT INTO obligation_definitions (namespace_id, name, metadata)
//	    SELECT
//	        CASE
//	            WHEN $1::TEXT != '' THEN $1::UUID
//	            ELSE fqns.namespace_id
//	        END,
//	        $2,
//	        $3
//	    FROM (
//	        SELECT
//	            CASE
//	                WHEN $1::TEXT != '' THEN $1::UUID
//	                ELSE NULL
//	            END as direct_namespace_id
//	    ) direct
//	    LEFT JOIN attribute_fqns fqns ON fqns.fqn = $4 AND $1::TEXT = ''
//	    WHERE
//	        ($1::TEXT != '' AND direct.direct_namespace_id IS NOT NULL) OR
//	        ($4::TEXT != '' AND fqns.namespace_id IS NOT NULL)
//	    RETURNING id, namespace_id, name, metadata
//	),
//	inserted_values AS (
//	    INSERT INTO obligation_values_standard (obligation_definition_id, value)
//	    SELECT io.id, UNNEST($5::VARCHAR[])
//	    FROM inserted_obligation io
//	    WHERE $5::VARCHAR[] IS NOT NULL AND array_length($5::VARCHAR[], 1) > 0
//	    RETURNING id, obligation_definition_id, value
//	)
//	SELECT
//	    io.id,
//	    io.name,
//	    io.metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    COALESCE(
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', iv.id,
//	                'value', iv.value
//	            )
//	        ) FILTER (WHERE iv.id IS NOT NULL),
//	        '[]'::JSON
//	    )::JSONB as values
//	FROM inserted_obligation io
//	JOIN attribute_namespaces n ON io.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	LEFT JOIN inserted_values iv ON iv.obligation_definition_id = io.id
//	GROUP BY io.id, io.name, io.metadata, n.id, fqns.fqn
func (q *Queries) createObligation(ctx context.Context, arg createObligationParams) (createObligationRow, error) {
	row := q.db.QueryRow(ctx, createObligation,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
		arg.NamespaceFqn,
		arg.Values,
	)
	var i createObligationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Metadata,
		&i.Namespace,
		&i.Values,
	)
	return i, err
}

const deleteObligation = `-- name: deleteObligation :execrows
DELETE FROM obligation_definitions WHERE id = $1
`

// deleteObligation
//
//	DELETE FROM obligation_definitions WHERE id = $1
func (q *Queries) deleteObligation(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteObligation, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getObligation = `-- name: getObligation :one
SELECT
    od.id,
    od.name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', ov.id,
            'value', ov.value
        )
    ) FILTER (WHERE ov.id IS NOT NULL) as values
    -- todo: add triggers and fulfillers
FROM obligation_definitions od
JOIN attribute_namespaces n on od.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
WHERE
    -- lookup by obligation id OR by namespace fqn + obligation name
    (
        -- lookup by obligation id
        (NULLIF($1::TEXT, '') IS NOT NULL AND od.id = $1::UUID)
        OR
        -- lookup by namespace fqn + obligation name
        (NULLIF($2::TEXT, '') IS NOT NULL AND NULLIF($3::TEXT, '') IS NOT NULL 
         AND fqns.fqn = $2::VARCHAR AND od.name = $3::VARCHAR)
    )
GROUP BY od.id, n.id, fqns.fqn
`

type getObligationParams struct {
	ID           string `json:"id"`
	NamespaceFqn string `json:"namespace_fqn"`
	Name         string `json:"name"`
}

type getObligationRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Namespace []byte `json:"namespace"`
	Metadata  []byte `json:"metadata"`
	Values    []byte `json:"values"`
}

// getObligation
//
//	SELECT
//	    od.id,
//	    od.name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', ov.id,
//	            'value', ov.value
//	        )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values
//	    -- todo: add triggers and fulfillers
//	FROM obligation_definitions od
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	WHERE
//	    -- lookup by obligation id OR by namespace fqn + obligation name
//	    (
//	        -- lookup by obligation id
//	        (NULLIF($1::TEXT, '') IS NOT NULL AND od.id = $1::UUID)
//	        OR
//	        -- lookup by namespace fqn + obligation name
//	        (NULLIF($2::TEXT, '') IS NOT NULL AND NULLIF($3::TEXT, '') IS NOT NULL
//	         AND fqns.fqn = $2::VARCHAR AND od.name = $3::VARCHAR)
//	    )
//	GROUP BY od.id, n.id, fqns.fqn
func (q *Queries) getObligation(ctx context.Context, arg getObligationParams) (getObligationRow, error) {
	row := q.db.QueryRow(ctx, getObligation, arg.ID, arg.NamespaceFqn, arg.Name)
	var i getObligationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Namespace,
		&i.Metadata,
		&i.Values,
	)
	return i, err
}

const listObligations = `-- name: listObligations :many
WITH counted AS (
    SELECT COUNT(od.id) AS total
    FROM obligation_definitions od
    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
    WHERE
        (NULLIF($1::TEXT, '') IS NULL OR od.namespace_id = $1::UUID) AND
        (NULLIF($2::TEXT, '') IS NULL OR fqns.fqn = $2::VARCHAR)
)
SELECT
    od.id,
    od.name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', ov.id,
            'value', ov.value
        )
    ) FILTER (WHERE ov.id IS NOT NULL) as values,
    -- todo: add triggers and fulfillers
    counted.total
FROM obligation_definitions od
JOIN attribute_namespaces n on od.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
CROSS JOIN counted
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
WHERE
    (NULLIF($1::TEXT, '') IS NULL OR od.namespace_id = $1::UUID) AND
    (NULLIF($2::TEXT, '') IS NULL OR fqns.fqn = $2::VARCHAR)
GROUP BY od.id, n.id, fqns.fqn, counted.total
LIMIT $4
OFFSET $3
`

type listObligationsParams struct {
	NamespaceID  string `json:"namespace_id"`
	NamespaceFqn string `json:"namespace_fqn"`
	Offset       int32  `json:"offset_"`
	Limit        int32  `json:"limit_"`
}

type listObligationsRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Namespace []byte `json:"namespace"`
	Metadata  []byte `json:"metadata"`
	Values    []byte `json:"values"`
	Total     int64  `json:"total"`
}

// listObligations
//
//	WITH counted AS (
//	    SELECT COUNT(od.id) AS total
//	    FROM obligation_definitions od
//	    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
//	    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	    WHERE
//	        (NULLIF($1::TEXT, '') IS NULL OR od.namespace_id = $1::UUID) AND
//	        (NULLIF($2::TEXT, '') IS NULL OR fqns.fqn = $2::VARCHAR)
//	)
//	SELECT
//	    od.id,
//	    od.name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', ov.id,
//	            'value', ov.value
//	        )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values,
//	    -- todo: add triggers and fulfillers
//	    counted.total
//	FROM obligation_definitions od
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	CROSS JOIN counted
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	WHERE
//	    (NULLIF($1::TEXT, '') IS NULL OR od.namespace_id = $1::UUID) AND
//	    (NULLIF($2::TEXT, '') IS NULL OR fqns.fqn = $2::VARCHAR)
//	GROUP BY od.id, n.id, fqns.fqn, counted.total
//	LIMIT $4
//	OFFSET $3
func (q *Queries) listObligations(ctx context.Context, arg listObligationsParams) ([]listObligationsRow, error) {
	rows, err := q.db.Query(ctx, listObligations,
		arg.NamespaceID,
		arg.NamespaceFqn,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listObligationsRow
	for rows.Next() {
		var i listObligationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Namespace,
			&i.Metadata,
			&i.Values,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObligation = `-- name: updateObligation :execrows
UPDATE obligation_definitions
SET
    name = COALESCE(NULLIF($1::TEXT, ''), name),
    metadata = COALESCE($2, metadata)
WHERE id = $3
`

type updateObligationParams struct {
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
	ID       string `json:"id"`
}

// updateObligation
//
//	UPDATE obligation_definitions
//	SET
//	    name = COALESCE(NULLIF($1::TEXT, ''), name),
//	    metadata = COALESCE($2, metadata)
//	WHERE id = $3
func (q *Queries) updateObligation(ctx context.Context, arg updateObligationParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateObligation, arg.Name, arg.Metadata, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
